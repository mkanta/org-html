# +HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/leftmenu.css">
# +HTML_HEAD: <script src="js/org-bindings.js" defer="defer"></script>
#+TITLE: Functional Programming Techniques in R
# +HTML_DOCTYPE: html5
# +HTML_CONTAINER: section
# Path to script, this refers to org-info.js in the current directory
# +INFOJS_OPT: path:org-info.js
# don't show toc, but local table of contents, 
#+INFOJS_OPT: toc:nil ltoc:t view:info mouse:underline buttons:nil 
#+INFOJS_OPT: up:index.html#toc
#+INFOJS_OPT: home:https://mkanta.github.io
* Why
Functional programming yields code with better structure. This is important for
a language like R, which isn't really designed to be a language for large 
software projects. Due to the inevitable mission creep affecting software
projects, codebases become larger than they should be and a lot messier.
Functional techniques reinject a dose of sanity into this kind of situation by
providing a clearer logical structure derived from λ-calculus.
Psychological
Possible Paradigm Change: Quantum Computing
* How
The essence of functional programming consists of combining short code snippets
using functors. Functors are functions that accept functions as arguments and
apply them to some data-structure or construct new functions from its arguments.

In addition to simplifying code re-use, this also allows the replacement of 
obscure loop constructions by functional application of code snippets to
sequences.
 
Examples: Lisp and Lisp-like dialects, ML and dialects (SML, Ocaml), Haskell.
* Hallmarks of a Functional Language
** Simple Function Manipulation
 - Simple Function Construction :: All functional languages provide a 
     constructor for function allowing to create new functions on the fly.
     This constructor is often called a /lambda/ and creates a function
     from an argument list and an expression.
 - Functions are Regular Datatypes :: The expressions generated by the λ
     construction are regular data-types, so they can be assigned to a
     variable to have a reference for later use, they can be handed as
     arguments to other functions or returned from functions.
 - Functions can be easily Curried :: A generalization of default arguments.
     (TODO: not quite, default arguments can be overridden)
     All functions are considered to have arity 1: They take one argument and 
     return another function. Thus, new functions can be created from existing 
     ones by a process reminiscent of partial evaluation. This process is 
     called /Currying/. 
** Loop Removal
Functional languages go a step further than just removing the insidious /goto/ 
statement, they remove all loops and replace them by a few easily recognizable
repeat-patterns.
 - Mapping :: some example
 - Filtering :: 
 - Folding :: some more
 - Zipping :: 
Everything that doesn't fit one of these patterns can be handled by recursion.
* How to do it in R
** Native Tools
 - Currying :: In the simplest case this can be done using default arguments.
** Additional Libraries (functional, purrr)
https://github.com/rstudio/cheatsheets/blob/master/purrr.pdf
** OCAML
https://github.com/pveber/ocaml-r
** F#
https://bluemountaincapital.github.io/FSharpRProvider/
** HaskellR
A topic for another day.
* Caveats
Efficiency: tail-end recursion, lazy evaluation
