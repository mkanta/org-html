# +HTML_HEAD: <script src="js/org-bindings.js" defer="defer"></script>
#+TITLE: Functional Programming Techniques in R
# +HTML_DOCTYPE: html5
# +HTML_CONTAINER: section
# Path to script, this refers to org-info.js in the current directory
#+INFOJS_OPT: path:../js/org-info.js
# don't show toc, but local table of contents, 
#+INFOJS_OPT: toc:nil ltoc:above view:info mouse:underline buttons:nil 
# +INFOJS_OPT: up:index.html#toc
#+INFOJS_OPT: up: ""
#+INFOJS_OPT: home:https://mkanta.github.io
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/stylesheet.css">
* Why
Functional programming yields code with a better logical structure. It allows to
express intent more explicitly and succinctly than imperative programming where
code is often cluttered with resource management, most notably memory management
by way of variables. 
#+BEGIN_SRC haskell
foldl (*) 1 $ take 5 $ filter odd [1..]
#+END_SRC
It addresses:
 - Mission Creep :: Many languages are nowadays used for purposes they weren't
   originally designed for. (R, Javascript, Python)
 - Code Management Issues :: Code changes, refactoring, code extension. 
   Programmers don't like to comment or read documentation. Functional code 
   is often more self-explanatory. 

   If typed  functional programming is used compiler will 
   detect most refactoring errors, but smaller self-contained code snippets
   make things easier even in the absence of static typing. 

   Do more work in less time.

   Examples: Emacs, Maxima, both huge codebases in LISP, well and alive since 
   the 1970's where other projects have failed.
 - Psychology :: Programming languages affect the thinking of the programmer.
   Since functional programming is deeply rooted in logic, the expectation
   is that the thinking of its users will be more precise. 
 - Possible Paradigm Change :: Quantum Computing
   No more access to memory during computation, imperative code needs to
   be rewritten for sure.
 - Parallelism :: Perhaps not an issue for R.
* Main Techniques
#+BEGIN_SRC haskell
divisible_by n x = mod x n == 0
odd = not . divisible_by 2
foldl (*) 1 $ take 5 $ filter odd [1..]
#+END_SRC
 - Combine short code snippets, sometimes unnamed, called \lambda expressions, 
   using functors. 
   Functors are functions that accept functions as arguments and apply them to 
   some data-structure or construct new functions from its arguments.
 - Replace most loops by easily recognizable iteration constructs where one or
   more of these code snippet is applied to a list.
 - Use recursion for ore obscure iterations not matching any of the iteration
   archetypes.

Examples: Lisp and Lisp-like dialects, ML and dialects (SML, Ocaml), Haskell.
* Details of Functional Techniques
** Simple Function Manipulation
 - Simple Function Construction :: All functional languages provide a 
     constructor for function allowing to create new functions on the fly.
     This constructor is often called a /lambda/ and creates a function
     from an argument list and an expression.
 - Functions are Regular Datatypes :: The expressions generated by the Î»
     construction are regular data-types, so they can be assigned to a
     variable to have a reference for later use, they can be handed as
     arguments to other functions or returned from functions.
 - Combining Code Snippets :: Function composition, tensoring et al, very
     lanuage dependent.
 - Easy Currying :: New functions are obtained from partial
     evaluations. A Haskell example:
#+BEGIN_SRC haskell
divisible_by :: Integral a => a -> a -> Bool
#+END_SRC
     This is right associative, ie ~a->a->Bool~ means ~a->(a->Bool)~, which
     implies that this is a function of one argument of type ~a~ returning
     a function ~a->Bool~.
     As a consequence, the ~odd~ function can be obtained by currying:
#+BEGIN_SRC haskell
divisible_by n x = mod x n == 0
even = divisible_by 2
odd = not . divisible_by 2
#+END_SRC
     All functions are considered to have arity 1: They take one argument and 
     return another function. Thus, new functions can be created from existing 
     ones by a process reminiscent of partial evaluation. This process is 
     called /Currying/. 
** Loop Removal
Functional languages go a step further than just removing the insidious /goto/ 
statement, they remove all loops and replace them by a few easily recognizable
repeat-patterns.
 - Mapping :: Runs code on a list and returns a list of results.
#+BEGIN_SRC haskell
map ((0) -) [1..5] -- change signs of list elements
#+END_SRC
 - Filtering :: Runs a boolean expression on a list and returns a list of
                elements satisfying the condition
#+BEGIN_SRC haskell
filter (divisible_by 2) [1..5] -- get sublist of even elements
#+END_SRC
 - Folding :: Runs code on an initial value and a list and returns a value
              accumulated by the code.
#+BEGIN_SRC haskell
foldl (*) 1 [1..5]   -- factorial 5!
#+END_SRC
 - Zipping :: Runs code on two lists to combine them into one list. There
              are usually variations of that for handling more than two
              lists at the time.
#+BEGIN_SRC haskell
zipWith (+) [1..5] [1..5]  -- adds lists componentwise
#+END_SRC
Everything that doesn't fit simple combinations of these patterns can be 
handled by explicit recursion.
* How About R
 - Based on Scheme, a Lisp dialect, inherently functional.
 - Designed for flexibility on the command line. This often turns into a 
   nightmare in terms of software architecture. Some problems:
   - Mixing positional and named parameters in functions.
   - S3 object system is very flexible.
** Native Tools
*** Functions as Datatypes 
   This comes very natural in R and is used most
   notably in functions like ~optimise~. A common procedure to perform a 
   maximum likelihood estimation:
   #+BEGIN_SRC R
   logli.poisson <- function(data) {
      ld <- length(data)
      sd <- sum(data)
      function(param) sd*log(param)-ld*param
   }
   #+END_SRC
   This can be fed into the ~optimise~ function:
   #+BEGIN_SRC R
   optimise(logli.poisson(x),c(0:100),maximum=TRUE)
   #+END_SRC
   This uses currying, resulting in efficient code and an extensible interface. 
   Without currying the temptation would be to define something like
   #+BEGIN_SRC R
   loglimp.poisson<-function(param,data) sum(data)*log(param)-length(data)*param
   #+END_SRC
   and then to pass the data argument through the ~optimise~ function:
   #+BEGIN_SRC R
   optimise(loglimp.poisson,c(0:100),data=x,maximum=TRUE)
   #+END_SRC
   but this would have to recalculate the length of the data vector and
   the sum of the data multiple times during the optimisation process.
   Of course the unnecessary recomputations can be optimised away doing
   something like: 
   #+BEGIN_SRC R
   loglimpx.poisson <- function(param,datasum,datalength){
                          datasum*log(param)-datalength*param
                       }
   #+END_SRC
   and passing the data sum and length through as extra arguments
   to ~optimise~. 

   This is a case where the flexibility becomes a curse
   and leads to messy interfaces, especially when something other than
   the Poisson likelihood needs to be used, ie a uniform distribution
   on positive data where the sum of the data is not a sufficient statistic.
*** Currying
   Surprisingly easy but somewhat hampered by parentheses.
   See maximum likelihood example.
   #+BEGIN_SRC R
   divisible_by <- function(n) function(x) x%%n == 0
   divisible_by(2)(3)
   FALSE
   even <- divisible_by(2)
   #+END_SRC
*** Loop Removal 
   Quite good but a bit non-standard. Mapping functions
   are implemented as ~apply~ functions such as ~lapply~, ~vapply~ and
   ~apply~ proper, but also see ~Map~ from ~funprog~ in base package.
   Folding is implemented as ~Reduce~ in the same package, which also
   provides ~Filter~.
   - Mapping :: Almost the same as above, at least on vectors. Based on
     ~mapply~.
     #+BEGIN_SRC R
     Map(function(x) -x,c(1:5)); #change signs
     #+END_SRC
   - Filtering :: Dito
     #+BEGIN_SRC R
     Filter(divisible_by(2), c(1:5)); # vector of even values
     #+END_SRC
   - Folding :: This is called ~Reduce~
     #+BEGIN_SRC R
     Reduce(function(x,y) x*y, c(1:5),1); #factorial
     #+END_SRC
   - Zipping :: This can actually flexibly be done with ~Map~.
     #+BEGIN_SRC R
     Map(function(x,y) x+y,c(1:5),c(1:5))
     #+END_SRC 
     or simply
     #+BEGIN_SRC R
     Map(`+`,c(1:5),c(1:5))
     #+END_SRC 
     or even simpler
     #+BEGIN_SRC R
     c(1:5) + c(1:5)
     #+END_SRC
     since R is a data processing language.
** Additional Libraries (functional, purrr)
Whilst everything is there, some things need some massaging. This is where
additional packages like ~functional~ or ~purrr~ come in. They provide 
  - function composition with ~Compose~ or ~compose~, respectively
  - currying with ~Curry~ or ~partial~, respectively
  - ~purrr~ also reimplements the loop functions
** External Bindings to Functional Programming Languages
*** OCAML
    https://github.com/pveber/ocaml-r
*** F#
    https://bluemountaincapital.github.io/FSharpRProvider/
*** HaskellR
    https://tweag.github.io/HaskellR/    
 
    A topic for another day.
*** PureR?
Purescript is a Haskell-style language originally created to generate 
javascript code. Now there are backends for
 - C: called pureC
 - Erlang: purerl
 - C++, Go: purescript-native
 An R backend to PureScript seems certainly possible and would be the ideal
 solution, so if someone could be found with the necessary resources...
* Concerns
Efficiency: tail-end recursion, lazy evaluation
#+BEGIN_SRC haskell
foldl (*) 1 $ take 5 $ filter odd [1..]
#+END_SRC
